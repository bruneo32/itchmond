<!DOCTYPE html>
<html lang="en" notranslate>

<!-- https://github.com/bruneo32/itchmond -->

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<style>
		:root {
			/* base size of round buttons: uses vmin so it scales with the smaller viewport dimension */
			--vk-size: 8vmin;
			/* default */
			--vk-rect-w: 18vmin;
			--vk-rect-h: 5vmin;
			--vk-gap: 2.5vmin;
			--vk-min-size: 44px;
			/* ensure minimum touch targets */
		}

		* {
			outline: none;
			box-sizing: border-box;
			font-family: inherit;
			color: inherit;
			margin: 0;
			padding: 0;
		}

		#context-menu {
			/* Make sure it can capture events */
			pointer-events: auto;
			display: none;
			z-index: 100;
			position: fixed;
			margin: 0;
			padding: 0;
			background: #EEE;
			font-family: monospace;
		}

		#context-menu hr {
			border: 1px solid rgba(0, 0, 0, 0.3);
			margin: 4px;
			padding: 0;
		}

		#context-menu p {
			cursor: pointer;
			margin: 0;
			padding: 8px;
			background: transparent;
		}

		#context-menu p:hover {
			background: rgba(0, 0, 0, 0.3);
		}

		#msg-layer {
			position: fixed;
			top: 16px;
			left: 16px;
			width: calc(100vw - 32px);
			padding: 1em;
			background: #09f;
			z-index: 500;
			border-radius: 12px;
			font-family: sans-serif;
			box-shadow: 0 0px 10px 0px;
		}

		#vk-layer {
			display: block;
			z-index: 2;
			position: fixed;
			inset: 0;
			margin: 0;
			padding: 0;
			pointer-events: none;
			font-family: monospace;
		}


		/* Base virtual-key style */
		#vk-layer .vk {
			position: absolute;
			pointer-events: auto;
			/* enable interaction */
			touch-action: manipulation;
			-webkit-user-select: none;
			user-select: none;
			background: rgba(127, 127, 127, 0.18);
			color: #fff;
			display: flex;
			align-items: center;
			justify-content: center;
			transition: transform .08s ease, opacity .08s ease;
			will-change: transform;
			/* position helpers via CSS variables set by JS or inline style */
			left: var(--vk-left, auto);
			right: var(--vk-right, auto);
			bottom: var(--vk-bottom, 4vh);
			top: var(--vk-top, auto);
		}


		/* Round buttons (A,B,X,Y, stick) */
		#vk-layer .vk.round {
			width: var(--vk-size, var(--vk-size));
			height: var(--vk-size, var(--vk-size));
			min-width: var(--vk-min-size);
			min-height: var(--vk-min-size);
			border-radius: 50%;
			font-size: calc(var(--vk-size) * 0.34);
			line-height: 1;
		}


		/* Rectangular buttons (L,R,select,start) */
		#vk-layer .vk.rect {
			width: var(--vk-rect-w);
			height: var(--vk-rect-h);
			min-width: 56px;
			min-height: 36px;
			border-radius: 10px;
			font-size: calc(var(--vk-rect-h) * 0.42);
			padding: 0 0.6em;
		}


		/* Active feedback */
		#vk-layer .vk:active,
		#vk-layer .vk.pressed {
			transform: scale(.92);
			opacity: .95;
		}


		/* Accessibility: larger touch targets on small screens */
		@media (max-width: 600px) {
			:root {
				--vk-size: 12vmin;
				--vk-rect-w: 24vmin;
				--vk-rect-h: 6.5vmin;
			}
		}


		/* Landscape phones may benefit from slightly different sizing */
		@media (orientation: landscape) and (max-width: 900px) {
			:root {
				--vk-size: 10vmin;
				--vk-rect-w: 20vmin;
				--vk-rect-h: 6vmin;
			}
		}


		/* Small improvement for high-DPI tiny viewports */
		@media (max-height: 420px) {
			:root {
				--vk-size: 9vmin;
			}
		}
	</style>
	<script>
		var config
		var isMobile = /mobile/i.test(navigator.userAgent)
		var __supports_webgl = undefined
		function has_webgl_support() {
			if (__supports_webgl !== undefined)
				return __supports_webgl
			try {
				const canvas = document.createElement('canvas')
				const gl = canvas.getContext('webgl')
				// delete canvas
				canvas.remove()
				__supports_webgl = !!window.WebGLRenderingContext && gl instanceof WebGLRenderingContext
			} catch (e) {
				__supports_webgl = false
			} finally {
				return __supports_webgl
			}
		}

		function blockEvent(e) {
			e.preventDefault()
			e.stopPropagation()
		}

		function bClick(e) {
			if (e.target == document.getElementById("vk-menu"))
				return
			hideMenu()
		}

		function bContextMenu(e) {
			blockEvent(e)
			const menu = document.getElementById("context-menu");
			menu.style.display = "block";
			menu.style.left = e.clientX + "px";
			menu.style.top = e.clientY + "px";
			menu.style.width = "unset";
			return 0;
		}

		function toggleMute(e, li) {
			blockEvent(e)
			hideMenu()
			if (!audioContext)
				return
			const isMute = audioContext.state === "suspended"
			audioContext[isMute ? "resume" : "suspend"]()
			li.innerText = !isMute ? "Unmute" : "Mute"
		}

		function toggleHWAccel(e, li) {
			blockEvent(e)
			hideMenu()
			if (!has_webgl_support()) return
			player.setHWAccel(!player._hwaccel)
		}

		function toggleVKLayer(e, li) {
			blockEvent(e)
			hideMenu()
			const vklayer = document.getElementById("vk-layer")
			vklayer.style.display =
				(vklayer.style.display && vklayer.style.display != "none")
					? "none" : "block"
			li.innerText = (vklayer.style.display != "none") ? "Hide virtual input" : "Show virtual input"
		}

		function hideMenu() {
			document.getElementById("context-menu").style.display = "none"
		}
		function showMenu(x, y) {
			menu.style.display = "block"
			menu.style.left = x + "px";
			menu.style.top = y + "px";
		}
		function toggleMenu() {
			const menu = document.getElementById("context-menu")
			if (menu && menu.style.display != "none")
				hideMenu()
			else
				showMenu()
		}

		function toggleFullscreen(e, li) {
			blockEvent(e)
			hideMenu()
			if (document.fullscreenElement) {
				document.exitFullscreen()
			} else {
				document.documentElement.requestFullscreen()
			}
		}
	</script>
</head>

<body onclick="bClick(event)" oncontextmenu="return bContextMenu(event)">
	<div id="context-menu">
		<p id="p-mute" onclick="toggleMute(event, this)" ontouchend="toggleMute(event, this)">
			Loading...
		</p>
		<p id="p-fullscreen" onclick="toggleFullscreen(event, this)" ontouchend="toggleFullscreen(event, this)">
			Toggle fullscreen
		</p>
		<hr>
		<p id="p-vklayer" onclick="toggleVKLayer(event, this)" ontouchend="toggleVKLayer(event, this)">
			Loading...
		</p>
		<p id="p-hwaccel" onclick="toggleHWAccel(event, this)" ontouchend="toggleHWAccel(event, this)">
			Loading...
		</p>
	</div>
	<div id="msg-layer" hidden="">
		<p id="msg-text"></p>
	</div>


	<div id="vk-layer">
		<!-- Virtual stick -->
		<div id="vk-stick-base" class="vk round" style="width:7vw;height:7vw;"></div>
		<div id="vk-stick" class="vk round" data-k="stick"
			style="left:16vmin;bottom:10vh;z-index:1;background:rgba(255,255,255,0.3)">
		</div>

		<!-- Virtual buttons -->
		<div class="vk round" data-k="a" style="right:4vmin; bottom:16vh; background:rgba(255,0,0,0.3);">A</div>
		<div class="vk round" data-k="b" style="right:16vmin; bottom:10vh; background:rgba(0,0,255,0.3);">B</div>
		<div class="vk round" data-k="y" style="right:28vmin; bottom:16vh; background:rgba(255,255,0,0.3);">Y</div>
		<div class="vk round" data-k="x" style="right:16vmin; bottom:22vh; background:rgba(0,255,0,0.3);">X</div>

		<div class="vk rect" data-k="l" style="left:0; bottom:50vh;transform:translateY(100%);">L</div>
		<div class="vk rect" data-k="r" style="right:0; bottom:50vh;transform:translateY(100%);">R</div>

		<div class="vk rect" data-k="select" style="left:25vmin; bottom:2vmin;">select</div>
		<div class="vk rect" data-k="start" style="right:25vmin; bottom:2vmin;">start</div>
	</div>


	<itchmond-player id="player"></itchmond-player>
	<script src="itchmond.min.js"></script>

	<script>
		hideMenu()

		// Prevent the emulator from being touched below the context menu
		const menu = document.getElementById('context-menu')
		menu.addEventListener('touchstart', blockEvent, { passive: false })
		menu.addEventListener('touchmove', blockEvent, { passive: false })
		menu.addEventListener('touchend', blockEvent, { passive: false })
		menu.addEventListener('touchcancel', blockEvent, { passive: false })
		menu.addEventListener('touchenter', blockEvent, { passive: false })
		menu.addEventListener('touchleave', blockEvent, { passive: false })
		menu.addEventListener('mousedown', blockEvent, { passive: false })
		menu.addEventListener('mouseup', blockEvent, { passive: false })
		menu.addEventListener('mousemove', blockEvent, { passive: false })

		// After the DOM is ready
		document.getElementById('vk-layer').style.display = "block"
		const vkStick = document.getElementById('vk-stick')
		if (vkStick) {
			const rect = vkStick.getBoundingClientRect();
			// vkStickPos: [centerY, centerX, width, height]
			window.vkStickPos = [
				(window.innerHeight - rect.top) + rect.height / 2,
				rect.left + rect.width / 2,
				rect.width,
				rect.height
			]

			// Initial pos trigger
			const stick_center_y = vkStickPos[0] - vkStickPos[3] / 2
			const stick_center_x = vkStickPos[1] - vkStickPos[2] / 2
			vkStick.style.bottom = stick_center_y + 'px';
			vkStick.style.left = stick_center_x + 'px';
			vkStick.style.width = vkStickPos[2] + 'px';
			vkStick.style.height = vkStickPos[3] + 'px';

			const base = document.getElementById('vk-stick-base');
			base.style.width = 'calc(' + vkStickPos[2] + 'px + 16px)';
			base.style.height = 'calc(' + vkStickPos[3] + 'px + 16px)';
			base.style.bottom = 'calc(' + (vkStickPos[0] - vkStickPos[3] / 2) + 'px - 8px)';
			base.style.left = 'calc(' + (vkStickPos[1] - vkStickPos[2] / 2) + 'px - 8px)';
		}

		var vks = document.getElementsByClassName('vk')
		for (var i = 0; i < vks.length; i++) {
			var vk = vks[i]
			var k = vks[i].getAttribute('data-k')
			if (k) {
				vkMap[k] = vk
				vkState[k] = [0, 0]
			}
		}

		const vklayer = document.getElementById('vk-layer')
		if (!isMobile) {
			// Hide the vklayer by default in pc
			vklayer.style.display = 'none'
		} else {
			// Fullscreen button on itch.io mobile is broken
			document.getElementById("p-fullscreen").style.display = "none"
		}

		// Set vklayer text
		if (vklayer) {
			document.getElementById('p-vklayer').innerText =
				(vklayer.style.display && vklayer.style.display != "none")
					? "Hide virtual input"
					: "Show virtual input"
		}

		// Responsive feedback style
		document.querySelectorAll('#vk-layer .vk').forEach(el => {
			// pointerdown/up works for mouse and touch
			el.addEventListener('pointerdown', e => { el.classList.add('pressed'); });
			el.addEventListener('pointerup', e => { el.classList.remove('pressed'); });
			el.addEventListener('pointercancel', e => { el.classList.remove('pressed'); });
		});

		// Read config and load ROM
		fetch("config.json").then(async (res) => {
			config = await res.json();
			document.body.style.backgroundColor = config["background"]
			document.title = config["title"]

			var player = document.getElementById("player");
			player.loadURL(config["rom"], () => {
				/* Uncomment to enable microphone input */
				if (config["enableMicrophone"])
					player.enableMicrophone();

				/* Set mute text */
				setTimeout(() => {
					const p_mute = document.getElementById("p-mute");
					p_mute.innerText = (audioContext.state !== "running") ? "Unmute" : "Mute";
				}, 200) // Wait until audio context is ready

				/* Set hwaccel text */
				const p_hwaccel = document.getElementById("p-hwaccel");
				if (!has_webgl_support()) {
					p_hwaccel.innerText = "WebGL not supported";
					p_hwaccel.style.color = "#888";
				} else {
					p_hwaccel.innerText = player._hwaccel ?
						"Disable hardware accelerated graphics" :
						"Enable hardware accelerated graphics";
				}

				uiUpdateLayout()
			})
		})

		if (isMobile) {
			let longTouchTimer = null;
			const LONG_TOUCH_MS = 600;

			function onPressStart(e) {
				if (!e.touches || !e.touches.length)
					return

				/* If touched on vklayer, ignore */
				const vklayer = document.getElementById('vk-layer');
				if (vklayer && vklayer.contains(e.target))
					return

				const touch = e.touches[0];
				hideMenu()
				longTouchTimer = setTimeout(() => {
					showMenu(touch.clientX, touch.clientY)
				}, LONG_TOUCH_MS)
			}

			function onPressEnd() {
				clearTimeout(longTouchTimer);
				longTouchTimer = null;
			}

			document.addEventListener('touchstart', onPressStart);
			document.addEventListener('touchend', onPressEnd);
			document.addEventListener('touchcancel', onPressEnd);
			document.addEventListener('touchleave', onPressEnd);
		}
	</script>
</body>

</html>
